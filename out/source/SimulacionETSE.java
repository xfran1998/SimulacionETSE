/* autogenerated by Processing revision 1283 on 2022-05-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class SimulacionEtse extends PApplet {


public class FireWorks 
{
  ArrayList<Rocket> _rockets;

  FireWorks() 
  {
    _rockets = new ArrayList<Rocket>();
  }
  
   public void addRocket(RocketType type, PVector pos, PVector vel, int c)
  {
    // Código para añadir un cohete a la simulación
    _rockets.add(new Rocket(type, pos, vel, c));
  }
  
   public int getNumRockets()
  {
    return _rockets.size();
  }
  
   public void run()
  {
    for (int i = 0; i < _rockets.size(); i++)
    {
      Rocket r = _rockets.get(i);
      r.run();
    }
    
    _simTime += SIM_STEP;    
  }
}
enum RocketType 
{
  ALEATORIO
}

final int NUM_ROCKET_TYPES = RocketType.values().length;

enum ParticleType 
{
  CASING,
  REGULAR_PARTICLE 
}

// Particle control:

FireWorks _fw;   // Main object of the program
int _numParticles = 0;   // Number of particles of the simulation

// Problem variables:

final float Gc = 9.801f;   // Gravity constant (m/(s*s))
final PVector G = new PVector(0.0f, Gc);   // Acceleration due to gravity (m/(s*s))
PVector _windVelocity = new PVector(10.0f, 0.0f);   // Wind velocity (m/s)
final float WIND_CONSTANT = 1.0f;   // Constant to convert apparent wind speed into wind force (Kg/s)
Boolean windMoving = false;

// Display values:

PrintWriter _output;
final boolean FULL_SCREEN = false;
final int DRAW_FREQ = 50;   // Draw frequency (Hz or Frame-per-second)
int DISPLAY_SIZE_X = 1000;   // Display width (pixels)
int DISPLAY_SIZE_Y = 1000;   // Display height (pixels)
final int [] BACKGROUND_COLOR = {10, 10, 25};

// Time control:

int _lastTimeDraw = 0;   // Last measure of time in draw() function (ms)
float _deltaTimeDraw = 0.0f;   // Time between draw() calls (s)
float _simTime = 0.0f;   // Simulated time (s)
float _elapsedTime = 0.0f;   // Elapsed (real) time (s)
final float SIM_STEP = 0.1f;   // Simulation step (s)

 public void settings()
{
  if (FULL_SCREEN)
  {
    fullScreen();
    DISPLAY_SIZE_X = displayWidth;
    DISPLAY_SIZE_Y = displayHeight;
  } 
  else
    size(DISPLAY_SIZE_X, DISPLAY_SIZE_Y);
}

 public void setup()
{
  frameRate(DRAW_FREQ);
  _lastTimeDraw = millis();

  _fw = new FireWorks();
  _numParticles = 0;

  _output = createWriter("data.csv");
  _output.println("tiempo,paso,framerate,n_part,tiemposindraw,tiempocondraw");
}

 public void printInfo()
{
  fill(255);
  text("Number of particles : " + _numParticles, width*0.025f, height*0.05f);
  text("Frame rate = " + 1.0f/_deltaTimeDraw + " fps", width*0.025f, height*0.075f);
  text("Elapsed time = " + _elapsedTime + " s", width*0.025f , height*0.1f);
  text("Simulated time = " + _simTime + " s ", width*0.025f, height*0.125f);
}

 public void drawWind()
{
  // Código para dibujar el vector que representa el viento
  stroke(255);
  PVector dir = _windVelocity.copy();
  dir.normalize();
  PVector arrow = dir.copy();
  line(width/2, height/2, (width/2)+_windVelocity.x, (height/2)+_windVelocity.y);
  arrow.rotate(radians(45));
  line((width/2)+_windVelocity.x, (height/2)+_windVelocity.y, (width/2)+_windVelocity.x-arrow.x*5, (height/2)+_windVelocity.y-arrow.y*5);
  arrow.rotate(radians(-90));
  line((width/2)+_windVelocity.x, (height/2)+_windVelocity.y, (width/2)+_windVelocity.x-arrow.x*5, (height/2)+_windVelocity.y-arrow.y*5);
  stroke(0);
}

 public void draw()
{
  int now = millis();
  _deltaTimeDraw = (now - _lastTimeDraw)/1000.0f;
  _elapsedTime += _deltaTimeDraw;
  _lastTimeDraw = now;

  //background(BACKGROUND_COLOR[0], BACKGROUND_COLOR[1], BACKGROUND_COLOR[2]);
  fill(BACKGROUND_COLOR[0], BACKGROUND_COLOR[1], BACKGROUND_COLOR[2], 50);
  rect(0, 0, width, height);
  
  _fw.run();
  printInfo();  
  drawWind();
  printFile();
}

 public void mousePressed()
{
  PVector pos = new PVector(mouseX, mouseY);
  PVector vel = new PVector((pos.x - width/2), (pos.y - height)).setMag(200);
  int c = color(random(255),random(255),random(255));

  int type = (int)(random(NUM_ROCKET_TYPES)); 
  _fw.addRocket(RocketType.values()[type], new PVector(width/2, height), vel, c);
}


 public void printFile(){
  // VARS:
  //tiempo _elapsedTime
  //numero de particulas
  //deltaTimeDraw
  _output.println(_elapsedTime + "," +_deltaTimeDraw + "," + "," + _numParticles);
}

 public void keyPressed()
{
  if (keyCode == UP) {
    windMoving = true;
  } 
  if (keyCode == BACKSPACE) {
    for (int i = 0; i < 50; i++) {
      PVector pos = new PVector(mouseX+random(0,200), mouseY+random(0,200));
      PVector vel = new PVector((pos.x - width/2), (pos.y - height)).setMag(200);
      int c = color(random(255),random(255),random(255));
    
      int type = (int)(random(NUM_ROCKET_TYPES)); 
      _fw.addRocket(RocketType.values()[type], new PVector(width/2, height), vel, c);
    }
  }

  if (key == 'e'){
    _output.flush(); // Writes the remaining data to the file 
    _output.close(); // Finishes the file 
    exit(); // Stops the program 
  }
}

 public void mouseMoved()
{
    if (windMoving) {
      PVector dir = new PVector(mouseX-(width/2), mouseY-(height/2));
      _windVelocity = dir.copy();
    } 
}

 public void keyReleased()
{
  windMoving = false;
}
public class Particle 
{
  ParticleType _type;

  PVector _s;   // Position (m)
  PVector _v;   // Velocity (m/s)
  PVector _a;   // Acceleration (m/(s*s))
  PVector _F;   // Force (N)
  float _m;   // Mass (kg)

  int _ttl;   // Time to live (iterations)
  int _color;   // Color (RGB)
  
  final static int _particleSize = 2;   // Size (pixels)
  final static int _casingLength = 25;   // Length (pixels)

  Particle(ParticleType type, PVector s, PVector v, float m, int ttl, int c) 
  {
    _type = type;
    
    _s = s.copy();
    _v = v.copy();
    _m = m;

    _a = new PVector(0.0f ,0.0f, 0.0f);
    _F = new PVector(0.0f, 0.0f, 0.0f);
   
    _ttl = ttl;
    _color = c;
  }

   public void run() 
  {
    update();
    display();
  }

   public void update() 
  {
    if (isDead())
      return;
      
    updateForce();
   
    // Codigo con la implementación de las ecuaciones diferenciales para actualizar el movimiento de la partícula
    PVector a = _F.copy();
    a.div(_m);
    
    // la gravedad no esta afectando
    _v.add(PVector.mult(a, SIM_STEP));
    _s.add(PVector.mult(_v, SIM_STEP));

    _ttl--;
  }
  
   public void updateForce()
  {
    // Código para calcular la fuerza que actua sobre la partícula
    _F = PVector.mult(G, _m);
    
    PVector x = _windVelocity.copy();
    x.normalize();
    
    PVector y = _v.copy();
    y.normalize();
    
    float k = (x.dot(y)+1)/2;
    
    _F.add(PVector.mult(_windVelocity, k));
    
    //print(_F + "\n");  
  }
  
   public PVector getPosition()
  {
    return _s;
  }

   public void display() 
  {
    
    // Codigo para dibujar la partícula. Se debe dibujar de forma diferente según si es la carcasa o una partícula normal
    if (_type == ParticleType.values()[0])
    {
      fill(_color);
      ellipse(_s.x, _s.y, _casingLength, _casingLength);
    }
    else 
    {
      fill(_color, _ttl*10);
      ellipse(_s.x, _s.y, _casingLength/2, _casingLength/2);
    }
  }
  
   public boolean isDead() 
  {
    if (_ttl < 0.0f) 
      return true;
    else
      return false;
  }
}
public class Rocket 
{
  RocketType _type;

  Particle _casing;
  ArrayList<Particle> _particles;
  
  PVector _launchPoint;
  PVector _launchVel;  
  PVector _explosionPoint;
  
  int _color;
  boolean _hasExploded;

  Rocket(RocketType type, PVector pos, PVector vel, int c) 
  {
    _type = type;
    _particles = new ArrayList<Particle>();
    
    _launchPoint = pos.copy();
    _launchVel = vel.copy();
    _explosionPoint = new PVector(0.0f, 0.0f, 0.0f);
    
    _color = c;
    _hasExploded = false;
    
    createCasing();
    _numParticles++;
  }
  
   public void createCasing()
  {
    // Codigo para crear la carcasa
    _casing = new Particle(ParticleType.values()[0], _launchPoint, _launchVel, 10, 40, _color);
  }
  
   public PVector createVelocityRand(float ang, float k, int m, int n){
    float vel = (cos(((2*asin(k))+(PI*m))/(2*n)))/(cos(((2*asin(k*cos(n*ang)))+(PI*m))/(2*n)));
    PVector v = new PVector(cos(ang), sin(ang));
    v.setMag(vel*50);
    return v;
  }
  
   public void explosion() 
  {
    // Codigo para utilizar el vector de partículas, creando particulas en él con diferentes velocidades para recrear distintos tipos de palmeras
    PVector vel = new PVector();
    float k = random(0,1);
    int m = (int)random(1,4);
    int n = (int)random(5,8);
    
    for (float ang = 0; ang <= 2*PI; ang += (2*PI)/50)
    {
      if (_type == RocketType.values()[0]){
        vel = createVelocityRand(ang, k, m, n);
      } else {
        vel = new PVector((cos(ang)+sin(ang*10))*100, (sin(ang)+sin(ang*5))*100);
      }
      
      _particles.add(new Particle(ParticleType.values()[1], _explosionPoint, vel, 1, 30, _color));
      _numParticles++;  
    }
    
    
  }

   public void run() 
  {
    // Codigo con la lógica de funcionamiento del cohete. En principio no hay que modificarlo.
    // Si la carcasa no ha explotado, se simula su ascenso.
    // Si la carcasa ha explotado, se genera su explosión y se simulan después las partículas creadas.
    // Cuando una partícula agota su tiempo de vida, es eliminada.
    
    if (!_casing.isDead())
      _casing.run();
    else if (_casing.isDead() && !_hasExploded)
    {
      _numParticles--;
      _hasExploded = true;

      _explosionPoint = _casing.getPosition().copy();
      explosion();
    }
    else
    {
      for (int i = _particles.size() - 1; i >= 0; i--) 
      {
        Particle p = _particles.get(i);
        p.run();
        
        if (p.isDead()) 
        {
          _numParticles--;
          _particles.remove(i);
        }
      }
    }
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SimulacionEtse" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
